import { openDB, DBSchema, IDBPDatabase } from 'idb';

// --- TYPE DEFINITIONS ---

export interface Category {
  id: number;
  name: string;
  createdAt: Date;
}

export interface Bookmark {
  id: number;
  url: string;
  title: string;
  description: string;
  categoryId: number; // Foreign key to Category
  isFavorite: 0 | 1; // Use 0 for false, 1 for true for indexing
  createdAt: Date;
}

// Represents the data for creating a new bookmark, omitting fields generated by the DB
export type NewBookmark = Omit<Bookmark, 'id' | 'createdAt'>;

// --- DATABASE SCHEMA ---

interface GridiaDB extends DBSchema {
  bookmarks: {
    key: number;
    value: Bookmark;
    indexes: { categoryId: number; isFavorite: 0 | 1 };
  };
  categories: {
    key: number;
    value: Category;
    indexes: { name: string };
  };
}

// --- DATABASE INITIALIZATION ---

const DB_NAME = 'gridia-db';
const DB_VERSION = 1;

let dbPromise: Promise<IDBPDatabase<GridiaDB>> | null = null;

function getDb(): Promise<IDBPDatabase<GridiaDB>> {
  if (!dbPromise) {
    dbPromise = openDB<GridiaDB>(DB_NAME, DB_VERSION, {
      upgrade(db, oldVersion, newVersion, transaction) {
        console.log(`Upgrading DB from version ${oldVersion} to ${newVersion}`);
        // Create bookmarks object store
        if (!db.objectStoreNames.contains('bookmarks')) {
          const bookmarksStore = db.createObjectStore('bookmarks', {
            keyPath: 'id',
            autoIncrement: true,
          });
          bookmarksStore.createIndex('categoryId', 'categoryId', { unique: false });
          bookmarksStore.createIndex('isFavorite', 'isFavorite', { unique: false });
        }

        // Create categories object store
        if (!db.objectStoreNames.contains('categories')) {
          const categoriesStore = db.createObjectStore('categories', {
            keyPath: 'id',
            autoIncrement: true,
          });
          categoriesStore.createIndex('name', 'name', { unique: true });

          // Add a default "Uncategorized" category
          transaction.done.then(() => {
            db.add('categories', { name: 'Uncategorized', createdAt: new Date() });
          });
        }
      },
    });
  }
  return dbPromise;
}


// --- CRUD FUNCTIONS ---

// Category Functions
export async function addCategory(name: string): Promise<number> {
  const db = await getDb();
  return db.add('categories', { name, createdAt: new Date() });
}

export async function getAllCategories(): Promise<Category[]> {
  const db = await getDb();
  return db.getAll('categories');
}

export async function deleteCategory(id: number): Promise<void> {
  const db = await getDb();
  // TODO: Decide how to handle bookmarks in a deleted category.
  // For now, we'll just delete the category.
  return db.delete('categories', id);
}

// Bookmark Functions
export async function addBookmark(bookmark: NewBookmark): Promise<number> {
  const db = await getDb();
  return db.add('bookmarks', { ...bookmark, createdAt: new Date() } as Bookmark);
}

export async function getAllBookmarks(): Promise<Bookmark[]> {
  const db = await getDb();
  return db.getAll('bookmarks');
}

export async function updateBookmark(bookmark: Bookmark): Promise<number> {
  const db = await getDb();
  return db.put('bookmarks', bookmark);
}

export async function deleteBookmark(id: number): Promise<void> {
  const db = await getDb();
  return db.delete('bookmarks', id);
}

export async function getBookmarksByCategory(categoryId: number): Promise<Bookmark[]> {
  const db = await getDb();
  return db.getAllFromIndex('bookmarks', 'categoryId', categoryId);
}

export async function getFavoriteBookmarks(): Promise<Bookmark[]> {
  const db = await getDb();
  return db.getAllFromIndex('bookmarks', 'isFavorite', 1);
}
